---
title: Make your first network request (WIP)
version: 1
---

import { Link } from "../../src/components/Link";
import { AutoSnippet, When } from "../../src/components/CodeSnippet";
import activity from "./first_request/activity";
import provider from "./first_request/provider";
import Legend from "./first_request/legend/legend";

:::note
This page is a work in progress
:::

Network requests are the core of any application. But there are a lot of things to consider when
making a network request:

- The UI should render a loading state while the request is being made
- Errors should be gracefully handled
- The request should be cached if possible

In this section, we will see how Riverpod can help us deal with all of this naturally.

## Setting up `ProviderScope`

Before we start making network requests, we need to make sure that `ProviderScope` is added at the
root of the application.

```dart
void main() {
  runApp(
    // To install Riverpod, we need to add this widget above everything else.
    // This should not be inside "MyApp" but as direct parameter to "runApp".
    ProviderScope(
      child: MyApp(),
    ),
  );
}
```

This is a necessary step to enable Riverpod in your project.

:::note
For complete installation steps (such as installing [riverpod_lint](https://pub.dev/packages/riverpod_lint)
and running the code-generator), check out <Link documentID="introduction/getting_started" />.
:::

## Performing your network request in a "provider"

Performing a network request is usually what we call "business logic".
In Riverpod, business logic is placed inside "providers".  
A provider is a super-powered function.
They behave like normal functions, with the added benefits of:

- being cached
- offering default error/loading handling
- being listenable
- automatically re-executing when some data changes

This make providers a perfect fit for _GET_ network requests (as for _POST/etc_ requests, see <Link documentID="essentials/side_effects" />).

As an example, let's make a simple application which suggests a random activity to do when bored.  
To do so, we will use the [Bored API](https://www.boredapi.com/). In particular,
we will perform a _GET_ request on the `/api/activity` endpoint. This returns a JSON object,
which we will parse into a Dart class instance.  
The next step would then be to display this activity in the UI. We would also make sure
to render a loading state while the request is being made, and to gracefully handle errors.

Sounds great? Let's do it!

### Defining the model

Before we start, we need to define the model of the data we will receive from the API.
This model will also need a way to parse the JSON object into a Dart class instance.

Generally, it is recommended to use a code-generator such as [Freezed](https://pub.dev/packages/freezed)
or [json_serializable](https://pub.dev/packages/json_serializable) to handle
JSON decoding. But of course, it's also possible to do it by hand.

Anyway, here's our model:

<AutoSnippet {...activity} />

### Creating the provider

Now that we have our model, we can start querying the API.  
To do so, we will need to create our first provider.

The syntax for defining a provider is as followed:

<When codegen={false}>
<Legend
  code={`final name = SomeProvider<Result>((ref) {
  <your logic here>
});
`}
  annotations={[
    {
      offset: 6,
      length: 4,
      label: "The provider variable",
       description: <>

This variable is what will be used to interact with our provider.  
The variable must be final and "top-level" (global).

</>
    },
    {
      offset: 13,
      length: 12,
      label: "The provider type",
      description: <>

Can be one of many (`Provider`, `FutureProvider`, `StreamProvider`, ...).  
The type of provider used depends on the return value of your function.
For example, to create a `Future<Activity>`, you'll want a `FutureProvider<Activity>`.

:::tip
Don't think in terms of "Which provider should I pick".
Instead, think in terms of "What do I want to return". The provider type
will follow naturally.
:::

</>
    },
    {
      offset: 35,
      length: 3,
      label: "Ref",
      description: <>

An object used to interact with other providers.  
All providers have one; either as parameter of the provider function,
or as a property of a Notifier.

</>
    },
    {
      offset: 44,
      length: 17,
      label: "The provider function",
      description: <>

This is where we place the logic of our providers.
This function will be called when the provider is first read.  
Subsequent reads will not call the function again, but instead return the cached value.

</>
    },
]}
/>
</When>

<When codegen={true}>
<Legend
  code={`@riverpod
Result myFunction(MyFunctionRef ref) {
  <your logic here>
}
`}
  annotations={[
    {
      offset: 0,
      length: 9,
      label: "The annotation",
       description: <>

All providers must be annotated with `@riverpod` or `@Riverpod()`.
This annotation can be placed on global functions or classes.  
Through this annotation, it is possible to configure the provider.

For example, we can disable "auto-dispose" (which we will see later) by writing `@Riverpod(keepAlive: true)`.

</>
    },
    {
      offset: 17,
      length: 10,
      label: "The annotated function",
       description: <>

The name of the annotated function determines how the provider
will be interacted with.  
For a given function `myFunction`, a generated `myFunctionProvider` variable will be generated.

Annotated functions **must** specify a "ref" as first parameter.  
Besides that, the function can have any number of parameters, including generics.
The function is also free to return a `Future`/`Stream` if it wishes to.

This function will be called when the provider is first read.  
Subsequent reads will not call the function again, but instead return the cached value.

</>
    },
    {
      offset: 28,
      length: 17,
      label: "Ref",
      description: <>

An object used to interact with other providers.  
All providers have one; either as parameter of the provider function,
or as a property of a Notifier.  
The type of this object is determined by the name of the function/class.

</>
    },
]}
/>
</When>

In our case, we want to _GET_ an activity from the API.  
Since a _GET_ is an asynchronous operation, that means we will want
to create a `Future<Activity>`.

Using the syntax defined previously, we can therefore define our provider as followed:

<AutoSnippet {...provider} />

In this snippet, we've defined a provider named `activityProvider` which
our UI will be able to use to obtain a random activity. It is worth nothing
that:

- The network request will not be executed until the UI reads the provider
  at least once.
- Subsequent reads will not re-execute the network request,
  but instead return the previously fetched activity.
- If the UI stops using this provider, the cache will be destroyed.
  Then, if the UI ever uses the provider again, that a new network request will be made.

:::info
Notice how we did not catch errors. This is voluntary, as providers
natively handle errors.  
If the network request or if the JSON parsing throws, the error
will be caught by Riverpod. Then, the UI will automatically have the necessary
information to render an error page.
:::

TODO:

- [ ] Consume the `FutureProvider` inside a Consumer
- [ ] Handle Loading/Error states

Going further: Making a Repository

- [ ] Cross-link to the Combining request page
- [ ] Mention how making a repository can be useful for testing
      to mock all requests in a single place
- [ ] Mention that making a repository can also be useful for
      deduplicating requests (e.g. to not fetch `/books/:id` if a given ID was already fetched in `/books`)
- [ ] Mention that making a repository is otherwise not that useful,
      as Riverpod already offers a way to mock
